TERRAFORM AND AWS TIPS AND TRICKS
==================================

TERRAFORM BEST PRACTICES
-------------------------

1. STATE MANAGEMENT
   - Always use remote state (S3 + DynamoDB for locking)
   - Never commit .tfstate files to version control
   - Enable state encryption
   - Use state locking to prevent concurrent modifications
   - Regularly backup state files

2. CODE ORGANIZATION
   - Separate environments using workspaces or directories
   - Use modules for reusable components
   - Keep main.tf focused, split into logical files
   - Use consistent naming conventions
   - Document your code with comments

3. VARIABLE MANAGEMENT
   - Use variables for everything that might change
   - Provide sensible defaults where appropriate
   - Use variable validation for critical inputs
   - Never hardcode credentials
   - Use sensitive = true for secrets in outputs

4. SECURITY
   - Use AWS Secrets Manager or SSM Parameter Store for secrets
   - Enable encryption at rest and in transit
   - Follow least privilege principle for IAM
   - Use security groups restrictively
   - Enable CloudTrail for audit logging
   - Scan for security issues with tools like tfsec or Checkov

5. VERSION CONTROL
   - Pin provider versions
   - Use required_version for Terraform
   - Commit .terraform.lock.hcl
   - Use semantic versioning for modules
   - Tag releases

6. RESOURCE NAMING
   - Use consistent naming conventions
   - Include environment in resource names
   - Use name_prefix for auto-generated names
   - Make names descriptive and meaningful

7. OUTPUTS
   - Export useful information as outputs
   - Use outputs to pass data between modules
   - Mark sensitive outputs appropriately
   - Document what each output represents

8. MODULES
   - Keep modules focused on single responsibility
   - Version your modules
   - Document module inputs and outputs
   - Use README.md in module directories
   - Test modules independently

9. TESTING
   - Test with terraform validate
   - Use terraform plan before apply
   - Implement automated testing (Terratest)
   - Test in non-production first
   - Use pre-commit hooks

10. COST OPTIMIZATION
    - Use t3/t4g instances instead of older types
    - Enable Auto Scaling
    - Use Reserved Instances or Savings Plans
    - Tag resources for cost allocation
    - Clean up unused resources regularly

COMMON TERRAFORM PATTERNS
--------------------------

1. CONDITIONAL RESOURCE CREATION
   resource "aws_instance" "web" {
     count = var.create_instance ? 1 : 0
     # ... configuration
   }

2. DYNAMIC BLOCKS FOR REPEATED CONFIGURATION
   dynamic "ingress" {
     for_each = var.ingress_rules
     content {
       from_port   = ingress.value.port
       to_port     = ingress.value.port
       protocol    = "tcp"
       cidr_blocks = ingress.value.cidr_blocks
     }
   }

3. FOR_EACH FOR RESOURCE SETS
   resource "aws_instance" "servers" {
     for_each = toset(var.server_names)
     
     ami           = var.ami_id
     instance_type = var.instance_type
     
     tags = {
       Name = each.key
     }
   }

4. DATA SOURCES FOR EXISTING RESOURCES
   data "aws_vpc" "existing" {
     default = true
   }

5. NULL RESOURCE FOR PROVISIONERS
   resource "null_resource" "cluster" {
     triggers = {
       cluster_instance_ids = join(",", aws_instance.cluster[*].id)
     }
     
     provisioner "local-exec" {
       command = "echo 'Cluster updated!'"
     }
   }

6. TEMPLATE FILES
   data "template_file" "user_data" {
     template = file("${path.module}/user_data.sh")
     
     vars = {
       db_endpoint = aws_db_instance.main.endpoint
     }
   }

AWS-SPECIFIC TIPS
-----------------

1. EC2 OPTIMIZATION
   - Use latest generation instance types (t3, m6i, c6i)
   - Enable detailed monitoring for production
   - Use Elastic IPs for static IP requirements
   - Implement proper backup strategies
   - Use placement groups for HPC workloads

2. VPC DESIGN
   - Plan CIDR ranges carefully
   - Use /24 subnets for easier management
   - Separate public and private subnets
   - Use multiple AZs for high availability
   - Implement VPC Flow Logs for troubleshooting

3. S3 OPTIMIZATION
   - Enable versioning for important buckets
   - Use lifecycle policies for cost optimization
   - Enable server-side encryption
   - Block public access by default
   - Use CloudFront for content delivery

4. RDS BEST PRACTICES
   - Enable Multi-AZ for production databases
   - Use read replicas for read-heavy workloads
   - Enable automated backups
   - Use parameter groups for configuration
   - Monitor with CloudWatch and Performance Insights

5. LAMBDA OPTIMIZATION
   - Right-size memory allocation
   - Use environment variables for configuration
   - Implement proper error handling
   - Use layers for shared dependencies
   - Enable X-Ray tracing for debugging

6. IAM SECURITY
   - Use IAM roles instead of access keys
   - Implement least privilege access
   - Use IAM policies effectively
   - Enable MFA for privileged users
   - Rotate credentials regularly

7. LOAD BALANCING
   - Use ALB for HTTP/HTTPS traffic
   - Use NLB for TCP/UDP traffic
   - Enable cross-zone load balancing
   - Configure health checks properly
   - Use SSL/TLS termination at ALB

8. AUTO SCALING
   - Use target tracking scaling policies
   - Set appropriate min/max/desired counts
   - Configure warm-up times
   - Use multiple scaling policies
   - Monitor scaling activities

TROUBLESHOOTING TIPS
--------------------

1. TERRAFORM ERRORS
   - Read error messages carefully
   - Check provider documentation
   - Verify AWS credentials and permissions
   - Check for circular dependencies
   - Use TF_LOG=DEBUG for detailed logs

2. STATE ISSUES
   - Use terraform state list to see resources
   - Import existing resources with terraform import
   - Remove resources with terraform state rm
   - Backup state before manual modifications
   - Use terraform state mv to rename resources

3. DEPENDENCY PROBLEMS
   - Use depends_on explicitly when needed
   - Check resource references
   - Use terraform graph to visualize dependencies
   - Break circular dependencies

4. AWS API ERRORS
   - Check service quotas/limits
   - Verify IAM permissions
   - Check for resource conflicts
   - Review CloudTrail for API errors
   - Use AWS CLI to test operations

5. PLAN/APPLY DIFFERENCES
   - Check for external changes
   - Use terraform refresh carefully
   - Review lifecycle rules
   - Check for time-based changes
   - Verify data source queries

PERFORMANCE OPTIMIZATION
------------------------

1. PARALLEL OPERATIONS
   - Terraform runs operations in parallel by default
   - Use -parallelism flag to adjust (default is 10)
   - Reduce for API rate limits

2. REMOTE STATE
   - Use S3 with DynamoDB for state locking
   - Enable state encryption
   - Use state versioning
   - Implement state backup strategy

3. LARGE INFRASTRUCTURES
   - Break into multiple state files
   - Use terraform state mv to reorganize
   - Use targeted applies: terraform apply -target
   - Implement proper module boundaries

4. CACHING
   - Use .terraform directory caching in CI/CD
   - Cache provider binaries
   - Use provider plugin cache

TERRAFORM WORKSPACE STRATEGIES
-------------------------------

1. ENVIRONMENT SEPARATION
   terraform workspace new dev
   terraform workspace new staging
   terraform workspace new prod
   
2. WORKSPACE-AWARE CONFIGURATION
   locals {
     environment = terraform.workspace
     instance_count = terraform.workspace == "prod" ? 3 : 1
   }

3. WORKSPACE NAMING
   - Use consistent naming: dev, staging, prod
   - Avoid using default workspace
   - Document workspace purpose

COST OPTIMIZATION TRICKS
-------------------------

1. Use AWS Cost Explorer with tags
2. Implement auto-shutdown for dev environments
3. Use Spot Instances for non-critical workloads
4. Right-size EC2 instances based on CloudWatch metrics
5. Use S3 Intelligent-Tiering
6. Delete unused EBS volumes and snapshots
7. Use AWS Budgets for cost alerts
8. Review and optimize data transfer costs

CI/CD INTEGRATION
-----------------

1. GitHub Actions Example:
   - terraform fmt -check
   - terraform init
   - terraform validate
   - terraform plan
   - terraform apply -auto-approve (for main branch)

2. GitLab CI Example:
   - Use Terraform Cloud for remote execution
   - Implement approval gates for production
   - Use variables for credentials

3. Jenkins Pipeline:
   - Use Terraform plugin
   - Implement plan/apply stages
   - Store state in S3

MONITORING AND ALERTING
------------------------

1. CloudWatch Metrics
   - Monitor CPU, memory, disk, network
   - Set alarms for thresholds
   - Use composite alarms

2. CloudWatch Logs
   - Centralize application logs
   - Use Log Insights for queries
   - Set up log metric filters

3. X-Ray
   - Trace Lambda functions
   - Monitor microservices
   - Identify bottlenecks

4. AWS Config
   - Track resource configurations
   - Implement compliance rules
   - Monitor configuration changes

DISASTER RECOVERY
------------------

1. Backup Strategies
   - Automated EBS snapshots
   - RDS automated backups
   - S3 versioning and replication
   - AMI backups

2. Multi-Region
   - Replicate critical data
   - Use Route 53 failover
   - Implement cross-region replication
   - Test failover procedures

3. Infrastructure as Code
   - Use Terraform to rebuild infrastructure
   - Version control all configurations
   - Test recovery procedures regularly
   - Document recovery procedures
