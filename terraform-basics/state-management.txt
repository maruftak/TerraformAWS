TERRAFORM STATE MANAGEMENT GUIDE
=================================

WHAT IS TERRAFORM STATE?
------------------------

Terraform state is a file that maps real-world resources to your configuration,
typically stored in JSON format for local backends or in backend-specific formats
for remote backends. It tracks metadata and improves performance for large infrastructures.

Default state file: terraform.tfstate
Backup file: terraform.tfstate.backup

WHY IS STATE IMPORTANT?
-----------------------

1. Resource Tracking - Maps configuration to real resources
2. Metadata Storage - Stores resource dependencies
3. Performance - Caches attribute values to avoid API calls
4. Collaboration - Enables team workflows with locking

STATE BACKENDS
--------------

LOCAL BACKEND (Default):
terraform {
  backend "local" {
    path = "terraform.tfstate"
  }
}

Pros: Simple, no setup required
Cons: No collaboration, no locking, manual backup

S3 BACKEND (Recommended for Teams):
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "project/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
    kms_key_id     = "arn:aws:kms:us-east-1:123456789:key/xxxxx"
  }
}

Pros: Remote storage, encryption, versioning, locking
Cons: Requires AWS setup

Setup S3 Backend:
# Create S3 bucket
aws s3 mb s3://my-terraform-state --region us-east-1

# Enable versioning
aws s3api put-bucket-versioning \
  --bucket my-terraform-state \
  --versioning-configuration Status=Enabled

# Enable encryption
aws s3api put-bucket-encryption \
  --bucket my-terraform-state \
  --server-side-encryption-configuration '{
    "Rules": [{
      "ApplyServerSideEncryptionByDefault": {
        "SSEAlgorithm": "AES256"
      }
    }]
  }'

# Create DynamoDB table for locking
aws dynamodb create-table \
  --table-name terraform-locks \
  --attribute-definitions AttributeName=LockID,AttributeType=S \
  --key-schema AttributeName=LockID,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST

TERRAFORM CLOUD BACKEND:
terraform {
  backend "remote" {
    organization = "my-org"
    
    workspaces {
      name = "my-workspace"
    }
  }
}

Pros: Free tier, UI, VCS integration, policy enforcement
Cons: External dependency, internet required

OTHER BACKENDS:
- azurerm (Azure)
- gcs (Google Cloud)
- consul
- etcd
- postgres
- artifactory

STATE COMMANDS
--------------

LIST RESOURCES:
terraform state list
terraform state list aws_instance.web
terraform state list 'aws_instance.web[*]'

SHOW RESOURCE:
terraform state show aws_instance.web
terraform state show 'aws_instance.web[0]'

MOVE/RENAME RESOURCE:
# Rename in state
terraform state mv aws_instance.old aws_instance.new

# Move to module
terraform state mv aws_instance.web module.web.aws_instance.web

# Move from module
terraform state mv module.web.aws_instance.web aws_instance.web

# Rename with count/for_each
terraform state mv 'aws_instance.web' 'aws_instance.web[0]'
terraform state mv 'aws_instance.web[0]' 'aws_instance.web["prod"]'

REMOVE FROM STATE:
terraform state rm aws_instance.web
terraform state rm 'module.web'
terraform state rm 'aws_instance.web[*]'

Note: This removes from state only, not from AWS!

PULL/PUSH STATE:
terraform state pull > terraform.tfstate.backup
terraform state push terraform.tfstate

Warning: Use push carefully, can cause data loss!

REPLACE PROVIDER:
terraform state replace-provider \
  registry.terraform.io/hashicorp/aws \
  registry.terraform.io/hashicorp/aws

IMPORT EXISTING RESOURCES
--------------------------

Import brings existing resources under Terraform management.

BASIC IMPORT:
# 1. Write the resource block
resource "aws_instance" "web" {
  # Configuration will be populated after import
}

# 2. Import the resource
terraform import aws_instance.web i-1234567890abcdef0

# 3. Run terraform plan to see differences
terraform plan

# 4. Update configuration to match
# Edit your .tf files to match the actual resource

# 5. Verify
terraform plan  # Should show no changes

IMPORT EXAMPLES:

EC2 Instance:
terraform import aws_instance.web i-1234567890abcdef0

VPC:
terraform import aws_vpc.main vpc-12345678

Subnet:
terraform import aws_subnet.public subnet-12345678

Security Group:
terraform import aws_security_group.web sg-12345678

S3 Bucket:
terraform import aws_s3_bucket.data my-bucket-name

RDS Instance:
terraform import aws_db_instance.main mydb

Route53 Zone:
terraform import aws_route53_zone.main Z1234567890ABC

IAM Role:
terraform import aws_iam_role.lambda lambda-role

IMPORT WITH COUNT:
terraform import 'aws_instance.web[0]' i-1234567890abcdef0
terraform import 'aws_instance.web[1]' i-0987654321fedcba0

IMPORT WITH FOR_EACH:
terraform import 'aws_instance.web["prod"]' i-1234567890abcdef0
terraform import 'aws_instance.web["dev"]' i-0987654321fedcba0

IMPORT INTO MODULE:
terraform import module.vpc.aws_vpc.main vpc-12345678

STATE LOCKING
-------------

State locking prevents concurrent state modifications.

S3 + DynamoDB Locking:
- Automatic with DynamoDB table configured
- Lock acquired before operations
- Released after completion or on error

Force Unlock (Emergency):
terraform force-unlock LOCK_ID

Warning: Only use if you're sure no other process is running!

Disable Locking (Not Recommended):
terraform apply -lock=false

STATE INSPECTION
----------------

View Current State:
terraform show

View Specific Resource:
terraform show aws_instance.web

View State in JSON:
terraform show -json

List Outputs:
terraform output
terraform output instance_ip

View State File:
cat terraform.tfstate | jq '.'

MIGRATING STATE
---------------

MIGRATING BACKENDS:

1. Add new backend configuration:
terraform {
  backend "s3" {
    bucket = "new-bucket"
    key    = "terraform.tfstate"
    region = "us-east-1"
  }
}

2. Initialize migration:
terraform init -migrate-state

3. Confirm migration when prompted

4. Verify:
terraform state list

MOVING STATE BETWEEN WORKSPACES:

1. Pull state from old workspace:
terraform workspace select old
terraform state pull > old.tfstate

2. Switch to new workspace:
terraform workspace select new

3. Push state:
terraform state push old.tfstate

SPLITTING STATE FILES:

1. Remove resources from current state:
terraform state rm aws_instance.web

2. Create new directory with backend config

3. Import into new state:
terraform import aws_instance.web i-1234567890abcdef0

STATE FILE STRUCTURE
--------------------

{
  "version": 4,
  "terraform_version": "1.5.0",
  "serial": 1,
  "lineage": "unique-id",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "web",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "id": "i-1234567890abcdef0",
            "ami": "ami-xxxxx",
            ...
          }
        }
      ]
    }
  ]
}

BEST PRACTICES
--------------

1. NEVER edit state files manually
2. ALWAYS use remote state for teams
3. ENABLE state encryption
4. ENABLE state versioning (S3)
5. ENABLE state locking
6. BACKUP state regularly
7. USE .gitignore for local state files
8. REVIEW state changes before applying
9. USE workspaces or separate state files per environment
10. DOCUMENT state management procedures

GITIGNORE FOR STATE:
.terraform/
*.tfstate
*.tfstate.*
*.tfstate.backup
.terraform.lock.hcl  # Optional, can commit this

STATE RECOVERY
--------------

Recover from Backup (S3):
1. List versions:
aws s3api list-object-versions \
  --bucket my-terraform-state \
  --prefix terraform.tfstate

2. Download specific version:
aws s3api get-object \
  --bucket my-terraform-state \
  --key terraform.tfstate \
  --version-id VERSION_ID \
  terraform.tfstate.recovered

3. Push recovered state:
terraform state push terraform.tfstate.recovered

Recover from .backup file:
cp terraform.tfstate.backup terraform.tfstate
terraform state pull

TROUBLESHOOTING
---------------

State Lock Error:
- Check if other process is running
- Wait for process to complete
- Use force-unlock only if certain no other process exists

State Drift:
terraform refresh              # Update state from real resources
terraform plan                 # See differences
terraform apply               # Reconcile differences

Corrupted State:
- Restore from backup
- Use S3 versioning to recover
- Rebuild state with imports if necessary

Missing Resources:
terraform import <resource> <id>

Duplicate Resources:
terraform state rm <resource>

STATE SECURITY
--------------

1. Encrypt state at rest (S3 encryption)
2. Encrypt state in transit (HTTPS)
3. Use IAM for access control
4. Enable MFA for state operations
5. Use KMS for encryption keys
6. Audit state access with CloudTrail
7. Never commit state to version control
8. Rotate encryption keys periodically
9. Implement least privilege access
10. Use separate state per environment

S3 BUCKET POLICY FOR STATE:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::ACCOUNT_ID:role/TerraformRole"
      },
      "Action": ["s3:ListBucket"],
      "Resource": "arn:aws:s3:::my-terraform-state"
    },
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::ACCOUNT_ID:role/TerraformRole"
      },
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Resource": "arn:aws:s3:::my-terraform-state/*"
    }
  ]
}

DYNAMODB PERMISSIONS FOR LOCKING:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:DeleteItem"
      ],
      "Resource": "arn:aws:dynamodb:*:*:table/terraform-locks"
    }
  ]
}
